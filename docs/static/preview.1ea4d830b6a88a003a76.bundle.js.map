{"version":3,"file":"static/preview.1ea4d830b6a88a003a76.bundle.js","sources":["webpack:///./src/DagreD3.jsx"],"sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\nimport * as dagreD3 from 'dagre-d3'\nimport * as d3 from 'd3'\n\nimport isEqual from 'react-fast-compare'\n\nclass DagreD3 extends React.Component {\n    constructor(props) {\n        super(props);\n    }\n\n    static defaultProps = {\n        height: \"1\",\n        width: \"1\",\n        // width and height are defaulted to 1 due to a FireFox bug(?) If set to 0, it complains.\n        fit: true,\n        interactive: false\n    };\n\n    static propTypes = {\n        nodes: PropTypes.object.isRequired,\n        edges: PropTypes.array.isRequired,\n        interactive: PropTypes.bool,\n        fit: PropTypes.bool,\n        height: PropTypes.string,\n        width: PropTypes.string,\n        shapeRenderers: PropTypes.objectOf(PropTypes.func),\n        onNodeClick: PropTypes.func,\n    };\n\n    shouldComponentUpdate(nextProps, nextState) {\n        return !isEqual(this.props.nodes, nextProps.nodes) ||\n            !isEqual(this.props.edges, nextProps.edges) ||\n            !isEqual(this.props.zoom, nextProps.zoom)\n    }\n\n    componentDidMount() {\n        this.renderDag();\n    }\n\n    componentDidUpdate() {\n        this.renderDag();\n    }\n\n    renderDag() {\n        let g = new dagreD3.graphlib.Graph().setGraph({});\n\n\n        for (let [id, node] of Object.entries(this.props.nodes))\n            g.setNode(id, node);\n\n        for (let edge of this.props.edges)\n            g.setEdge(edge[0], edge[1], edge[2]); // from, to, props\n\n        // Set up an SVG group so that we can translate the final graph.\n        let svg = d3.select(this.nodeTree);\n        let inner = d3.select(this.nodeTreeGroup);\n\n        // set up zoom support\n        if (this.props.interactive) {\n            let zoom = d3.zoom().on(\"zoom\",\n                () => inner.attr(\"transform\", d3.event.transform));\n            svg.call(zoom);\n        }\n\n        // Create the renderer\n        let render = new dagreD3.render();\n\n        // set up custom shape renderers\n        if (this.props.shapeRenderers)\n            for (let [shape, renderer] of Object.entries(this.props.shapeRenderers))\n                render.shapes()[shape] = renderer;\n\n        // Run the renderer. This is what draws the final graph.\n        render(inner, g);\n\n\n        // TODO add padding?\n        if (this.props.fit) {\n            let {height: gHeight, width: gWidth} = g.graph();\n            let {height, width} = this.nodeTree.getBBox();\n            let transX = width - gWidth;\n            let transY = height - gHeight;\n            svg.attr(\"height\", height);\n            svg.attr(\"width\", width);\n            inner.attr(\"transform\", d3.zoomIdentity.translate(transX, transY))\n        }\n\n        if (this.props.onNodeClick)\n            svg.selectAll('.dagre-d3 .node').on('click',\n                    id => this.props.onNodeClick(id));\n    }\n\n    render() {\n        return (\n            <svg className='dagre-d3' ref={(r) => {this.nodeTree = r}}\n                 width={this.props.height}\n                 height={this.props.width}>\n\n                <g ref={(r) => {this.nodeTreeGroup = r}}/>\n            </svg>\n        );\n    }\n}\n\nexport default DagreD3;"],"mappings":"AAAA","sourceRoot":""}